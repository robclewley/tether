#summary Proposed coding ideas

= Introduction =
This page is a place to put code snippets and ideas on code logic for features that will be implemented later. 


= Unit descriptions =
Units will be defined by objects with the following attributes:
  * maxHP = int (max HP of the unit)
  * currentHP = int (current health of unit)
    * OMBC allowed health in half-HP increments (from cluster bomb and possibly from splash damage)
  * needstether = bool (whether or not this unit must be tethered to survive)
  * sightrange = int (distance this unit can see in FoW)
  * parent = reference (unit which this unit's tether comes from)
  * children = array of references (units which are tethered from this unit)
  * isdisabled = bool (whether unit is active or disabled)
  * isvirused = bool (whether unit is currently infected)
    * information about virus propagation needs to be stored, but this may not be the best place


= Version System =
As the game progresses different versions will be made as upgrades occur. As features are implemented or changed it is highly likely that networking protocols, map files, save files and preference files will become incompatible. In order to prevent errors due to incompatibilities a version number will be hardcoded for each of these systems. In the event the game finds an incompatible version (such as for a recent update) then the game will be capable of taking the appropriate actions. The names of these variables and their values currently are:
  * gvars.settingsversion = 2 (for game settings)
  * gvars.networkversion = 0 (for networking)
  * gvars.mapversion = 0 (for maps)
  * gvars.savegameversion = 0 (for game saves)

= Map System =
For each game map there will actually be two maps that will be synced to each other. First there will be a 'logicmap' which will be the location of terrain the computer reads from the map file. There will also be an 'imagemap' which will be nothing more then a PNG file created from the logicmap. The imagemap is what the player will see when playing the game and moving around the map will function by simply showing different sections of the image. The computer will continue to use the logicmap in order to determine collisions between objects and the terrain. This brings up the question of how this will affect FoW though. If the map the player sees is nothing more then standard image being moved around will the FoW be part of that image or will we need have to have another 'map' that moves around identically to the imagemap but is shadowed for the parts the FoW covers?

= Hosting =
It would be good to have a system whereby if the host goes down one of the clients will automatically pick it up and keep the game going. I was thinking of a system where each player has a playerID sequentially assigned to them by the host. The host also keeps track of the IP's of the clients and distributes it to all clients along with the playerID's. If the host goes down each client will automatically attempt to connect to the IP of the next active computer in line which takes over hosting duties. Another option would be to have a ring host where the 'host' is the person who's turn it is. This means that each client will need to store all the server information including the IP addresses of each client in order to take over hosting responsibilities when necessary. Another alternative to this would be to have every client function as a host concurrently while the game is running and simply pass responsibility for each turn to the player who's turn it currently happens to be.

= Processes =
I am thinking about making the server/hosting system a seperate process from the main moon.py client. Although the client must be capable of launching the host system from within a GUI environment it might be nice to allow users the option to launch the host directly from outside the game using command line arguments. This would allow hosting of games on non-GUI servers. I think the best way to integrate the host with the client GUI is by simply having the client launch the host using command line arguments itself in the background. This would make running concurrent hosts on all systems irrelevant. Since each player would be hosting there would be no point in running it outside the client. There would also then be no point in having the host function as a seperate process.

Here's my take (zaak):

"When the game starts, the host sends everyone's IP address to all the
clients. If the host drops, the clients will get a button that lets
them take over as host, and a field to enter a new host address. The
players can communicate outside of the game to determine who will
host.

When the new host starts, it tries to connect to all the client IP
addresses. This will only work for the ones with open ports. The ones
without open ports can enter the address of the new host to connect.

All of the clients will have an autogenerated password (made at the
start of the game) so they all know they're the clients of the host
that dropped. If a client who wasn't in the game at first (eg the host
whose computer crashed) wants to join, he can get the auto-password
from the new host.

I think that takes care of recovery. It's a bit complex, but not more
than necessary I hope."

Based on whats been discussed it seems like zaaks idea is the best balance between stability, ease of coding and host recovery in the event of a system failure. We'll go ahead with this plan for developing the host/client system. 